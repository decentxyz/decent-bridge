// SPDX-License-Identifier: MIT
//
//▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
//▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
//▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒░░░░░░░░▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒░░░░░░░▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒

pragma solidity ^0.8.2;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

//

contract C4TEST is ERC721, Ownable {
    struct CdMemory {
        address writerAddress;
        uint256 songChoiceId;
        bool written;
    }

    mapping(uint256 => CdMemory) public readCdMemory;
    mapping(address => mapping(uint256 => bool)) public usedNonces; //used for making sure the nonce of signed message is only used once per address for cross-chain minting

    string private _baseTokenURI =
        "https://c4-generator.vercel.app/api/cdMetadata/"; // New state variable to store the baseURI.

    address public mostRecentMinter;
    address public mostCdsOwned = 0x50331e2f6e3373d517BE7B0228bcb0452DA783aa; // random address to get first comparison to work
    address public beneficiaryAddress;

    uint256 _tokenIdCounter = 1;
    uint256 public mintCount;
    uint256 public maximumMintAmount = 15000;
    uint256 public writeCount;
    uint256 public mintPrice = 0.01 ether;
    uint256 public allowListMintPrice = 0.008 ether;

    bool public saleEnabled = false;

    bytes32 public allowListMerkleRoot;

    event NonceCheck(address indexed signer, uint256 nonce, bool isUsed);
    event CdMinted(uint256 tokenId, address minter); // event that is emitted whenever a Cd is minted
    event CdMemorySet(uint256 tokenId, address setter, uint256 songChoiceId); // event that is emitted whenever a Cd's data is set

    constructor() Ownable() ERC721("C4TEST - v4 w multi mintwrite", "C4") {
        beneficiaryAddress = msg.sender; // Set the deployer/original owner as the initial beneficiary
    }

    // New function to set the baseURI. Only the owner can call this.
    function setBaseURI(string memory baseURI) public onlyOwner {
        _baseTokenURI = baseURI;
    }

    // Override the default baseURI function to read from the state variable.
    function _baseURI() internal view override returns (string memory) {
        return _baseTokenURI;
    }

    function _mintTokens(address to, uint256 numberOfTokens) internal {
        require(
            numberOfTokens > 0,
            "Number of tokens to mint must be greater than 0"
        );
        require(saleEnabled, "Minting is not currently enabled");
        require(
            msg.value >= mintPrice * numberOfTokens,
            "Insufficient funds to mint"
        );
        require(mintCount <= maximumMintAmount, "Maximum Mint Amount Reached");

        for (uint256 i = 0; i < numberOfTokens; i++) {
            uint256 tokenId = _tokenIdCounter;
            _safeMint(to, tokenId);
            mintCount += 1;
            emit CdMinted(tokenId, to);
            _tokenIdCounter++;
        }
        mostRecentMinter = to;
        if (balanceOf(mostCdsOwned) < balanceOf(msg.sender)) {
            mostCdsOwned = msg.sender;
        }
    }

    function safeMint(address to) public payable {
        _mintTokens(to, 1);
    }

    function multiMint(uint256 numberOfTokens, address to) public payable {
        _mintTokens(to, numberOfTokens);
    }

    function _ownerMint(address to, uint256 numberOfTokens) public {
        require(
            numberOfTokens > 0,
            "Number of tokens to mint must be greater than 0"
        );

        for (uint256 i = 0; i < numberOfTokens; i++) {
            uint256 tokenId = _tokenIdCounter;
            _safeMint(to, tokenId);
            mintCount += 1;
            _tokenIdCounter++;
        }
        mostRecentMinter = to;
        if (balanceOf(mostCdsOwned) < balanceOf(to)) {
            mostCdsOwned = to;
        }
    }

    //Merkle Tree Allow List functions

    function setMerkleRoot(bytes32 newMerkleRoot) public onlyOwner {
        allowListMerkleRoot = newMerkleRoot;
    }

    function isValidProof(
        bytes32[] calldata merkleProof,
        address _address
    ) public view returns (bool) {
        bool valid = MerkleProof.verify(
            merkleProof,
            allowListMerkleRoot,
            keccak256(abi.encodePacked(_address))
        );
        return valid;
    }

    function allowListSafeMint(
        bytes32[] calldata merkleProof,
        address to
    ) public payable {
        bool allowListStatus = isValidProof(merkleProof, to);
        require(allowListStatus == true, "Invalid Proof");
        _allowListMintTokens(to, 1);
    }

    function allowListMultiMint(
        bytes32[] calldata merkleProof,
        uint256 numberOfTokens,
        address to
    ) public payable {
        bool allowListStatus = isValidProof(merkleProof, to);
        require(allowListStatus == true, "Invalid Proof");
        _allowListMintTokens(to, numberOfTokens);
    }

    function _allowListMintTokens(address to, uint256 numberOfTokens) internal {
        require(
            numberOfTokens > 0,
            "Number of tokens to mint must be greater than 0"
        );
        require(saleEnabled, "Minting is not currently enabled");
        require(
            msg.value >= allowListMintPrice * numberOfTokens,
            "Insufficient funds to mint"
        );
        require(mintCount <= maximumMintAmount, "Maximum Mint Amount Reached");

        for (uint256 i = 0; i < numberOfTokens; i++) {
            uint256 tokenId = _tokenIdCounter;
            _safeMint(to, tokenId);
            mintCount += 1;
            emit CdMinted(tokenId, to);
            _tokenIdCounter++;
        }
        mostRecentMinter = to;
        if (balanceOf(mostCdsOwned) < balanceOf(msg.sender)) {
            mostCdsOwned = msg.sender;
        }
    }

    function writeToDisc(uint256 tokenId, uint256 songChoiceId) public {
        require(
            ownerOf(tokenId) == msg.sender,
            "Only the owner of this token can set CdMemory"
        );

        require(
            songChoiceId >= 1 && songChoiceId <= 5,
            "Invalid song choice ID"
        );

        CdMemory storage cd = readCdMemory[tokenId];
        require(
            !cd.written,
            "CdMemory is already written and cannot be updated."
        );

        cd.writerAddress = msg.sender;
        cd.songChoiceId = songChoiceId;
        cd.written = true; // Mark the data as written after the initial update.

        //update the write count
        writeCount += 1;

        emit CdMemorySet(tokenId, msg.sender, songChoiceId);
    }

    function multiWriteToDisc(
        uint256[] memory tokenIds,
        uint256[] memory songSelections
    ) public {
        require(
            tokenIds.length == songSelections.length,
            "Input arrays must have the same length"
        );

        for (uint256 i = 0; i < tokenIds.length; i++) {
            uint256 tokenId = tokenIds[i];
            uint256 songChoiceId = songSelections[i];

            // Check if CdMemory is not written before allowing an update
            CdMemory storage cd = readCdMemory[tokenId];
            require(
                ownerOf(tokenId) == msg.sender,
                "Only the owner can set CdMemory"
            );
            require(
                songChoiceId >= 1 && songChoiceId <= 5,
                "Invalid song choice ID"
            );
            require(!cd.written, "One or more tokens are already written.");

            // Update CdMemory and mark it as written
            cd.writerAddress = msg.sender;
            cd.songChoiceId = songChoiceId;
            cd.written = true;

            writeCount += 1;

            emit CdMemorySet(tokenId, msg.sender, songChoiceId);
        }
    }

    //Cross chain writing to disc via the Box

    function multiWriteToDiscSignature(
        uint256[] memory tokenIds,
        uint256[] memory songSelections,
        uint256 nonce,
        bytes memory signature
    ) public {
        require(
            tokenIds.length == songSelections.length,
            "tokenIds and songSelections arrays must have the same length"
        );

        //Constructing the signed hash for signer address recovery
        bytes32 hash = keccak256(
            abi.encodePacked(tokenIds, songSelections, nonce)
        );

        bytes32 ethSignedHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", hash)
        );

        address signer = recoverSigner(ethSignedHash, signature);

        emit NonceCheck(signer, nonce, usedNonces[signer][nonce]);

        require(!usedNonces[signer][nonce], "Nonce already used"); //check to see if nonce has been used for this signer

        usedNonces[signer][nonce] = true; // if nonce hasn't been used, set it to true to indicate it has now been used

        for (uint256 i = 0; i < tokenIds.length; i++) {
            uint256 tokenId = tokenIds[i];
            uint256 songChoiceId = songSelections[i];

            // Check if CdMemory is not written before allowing an update
            CdMemory storage cd = readCdMemory[tokenId];
            require(
                ownerOf(tokenId) == signer,
                "Only the owner can set CdMemory"
            );
            require(
                songChoiceId >= 1 && songChoiceId <= 5,
                "Invalid song choice ID"
            );
            require(!cd.written, "One or more tokens are already written.");

            // Update CdMemory and mark it as written
            cd.writerAddress = msg.sender;
            cd.songChoiceId = songChoiceId;
            cd.written = true;

            writeCount += 1;

            emit CdMemorySet(tokenId, msg.sender, songChoiceId);
        }
    }

    //Helper function to determine signer address based on the signed hash and the signature

    function recoverSigner(
        bytes32 ethSignedHash,
        bytes memory signature
    ) public pure returns (address) {
        // Extract the r, s, and v values from the signature
        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);

        // Recover and return the signer address
        return ecrecover(ethSignedHash, v, r, s);
    }

    //Helper Function to split signature into RSV values
    function splitSignature(
        bytes memory signature
    ) public pure returns (bytes32 r, bytes32 s, uint8 v) {
        require(signature.length == 65, "Invalid signature length");

        assembly {
            // Slice the r, s, and v components from the signature
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
    }

    ////Admin Functions
    function toggleSaleEnabled() public onlyOwner {
        saleEnabled = !saleEnabled;
    }

    // Function to set the minting price, accessible only by the owner.
    function setMintPrice(uint256 price) public onlyOwner {
        mintPrice = price;
    }

    function setBeneficiaryAddress(
        address _beneficiaryAddress
    ) public onlyOwner {
        require(_beneficiaryAddress != address(0), "Invalid address");
        beneficiaryAddress = _beneficiaryAddress;
    }

    // Function to withdraw the contract's balance (received ETH) to the owner.
    function withdrawBalance() public onlyOwner {
        require(
            beneficiaryAddress != address(0),
            "Beneficiary address is not set"
        );
        (bool success, ) = payable(beneficiaryAddress).call{
            value: address(this).balance
        }("");
        require(success, "Transfer failed");
    }
}
