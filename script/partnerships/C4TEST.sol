// SPDX-License-Identifier: MIT
//
//▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
//▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒
//▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒░░░░░░░░▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒░░░░░░░▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒
//▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒░░░░░░░░░░░░░░░░░░░░▒▒▒▒▒▒
//▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒

pragma solidity ^0.8.2;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

//

contract C4TEST is
    ERC721,
    Ownable //C4 by Songcamp
{
    struct CdMemory {
        address writerAddress;
        uint256 songChoiceId;
        bool written;
    }

    mapping(uint256 => CdMemory) public readCdMemory;
    mapping(address => uint256) public userMintCount;

    string private _baseTokenURI = "https://data.song.camp/api/cdmetadata/"; // New state variable to store the baseURI.

    address public mostRecentMinter;
    address public mostCdsMinted = 0x50331e2f6e3373d517BE7B0228bcb0452DA783aa; // random address to get first comparison to work @Isaac, I had trouble getting this to work with the zero address!
    address public beneficiaryAddress;

    uint256 _tokenIdCounter = 1;
    uint256 public mintCount;
    uint256 public maximumMintAmount = 15000;
    uint256 public writeCount;
    uint256 public mintPrice = 0.00001 ether;
    uint256 public allowListMintPrice = 0.008 ether;

    bool public saleEnabled = false;

    bytes32 public allowListMerkleRoot;

    event CdMinted(uint256 tokenId, address minter); // event that is emitted whenever a Cd is minted
    event CdMemorySet(uint256 tokenId, address setter, uint256 songChoiceId); // event that is emitted whenever a Cd's data is set

    constructor()
        Ownable()
        ERC721("Version Lock Test", "SCtest") //C4 by Songcamp , $C4
    {
        beneficiaryAddress = msg.sender; // Set the deployer/original owner as the initial beneficiary
    }

    // New function to set the baseURI. Only the owner can call this.
    function setBaseURI(string memory baseURI) public onlyOwner {
        _baseTokenURI = baseURI;
    }

    // Override the default baseURI function to read from the state variable.
    function _baseURI() internal view override returns (string memory) {
        return _baseTokenURI;
    }

    function _mintTokens(address to, uint256 numberOfTokens) internal {
        require(
            numberOfTokens > 0,
            "Number of tokens to mint must be greater than 0"
        );
        require(saleEnabled, "Minting is not currently enabled");
        require(
            msg.value == mintPrice * numberOfTokens,
            "msg.value is incorrect"
        );
        require(
            mintCount + numberOfTokens <= maximumMintAmount,
            "Maximum Mint Amount Reached"
        );

        for (uint256 i = 0; i < numberOfTokens; i++) {
            uint256 tokenId = _tokenIdCounter;
            _safeMint(to, tokenId);
            mintCount += 1;
            emit CdMinted(tokenId, to);
            _tokenIdCounter++;
        }

        mostRecentMinter = to;

        userMintCount[to] += numberOfTokens;

        if (userMintCount[mostCdsMinted] < userMintCount[to]) {
            mostCdsMinted = to;
        }
    }

    function safeMint(address to) public payable {
        _mintTokens(to, 1);
    }

    function multiMint(uint256 numberOfTokens, address to) public payable {
        _mintTokens(to, numberOfTokens);
    }

    function ownerMint(address to, uint256 numberOfTokens) public {
        require(
            numberOfTokens > 0,
            "Number of tokens to mint must be greater than 0"
        );
        require(
            mintCount + numberOfTokens <= maximumMintAmount,
            "Maximum Mint Amount Reached"
        );

        for (uint256 i = 0; i < numberOfTokens; i++) {
            uint256 tokenId = _tokenIdCounter;
            _safeMint(to, tokenId);
            mintCount += 1;
            _tokenIdCounter++;
        }
    }

    //Merkle Tree Allow List functions

    function setMerkleRoot(bytes32 newMerkleRoot) public onlyOwner {
        allowListMerkleRoot = newMerkleRoot;
    }

    function isValidProof(
        bytes32[] calldata merkleProof,
        address _address
    ) public view returns (bool) {
        bool valid = MerkleProof.verify(
            merkleProof,
            allowListMerkleRoot,
            keccak256(abi.encodePacked(_address))
        );
        return valid;
    }

    function allowListSafeMint(
        bytes32[] calldata merkleProof,
        address to
    ) public payable {
        bool allowListStatus = isValidProof(merkleProof, to);
        require(allowListStatus == true, "Invalid Proof");
        _allowListMintTokens(to, 1);
    }

    function allowListMultiMint(
        bytes32[] calldata merkleProof,
        uint256 numberOfTokens,
        address to
    ) public payable {
        bool allowListStatus = isValidProof(merkleProof, to);
        require(allowListStatus == true, "Invalid Proof");
        _allowListMintTokens(to, numberOfTokens);
    }

    function _allowListMintTokens(address to, uint256 numberOfTokens) internal {
        require(
            numberOfTokens > 0,
            "Number of tokens to mint must be greater than 0"
        );
        require(saleEnabled, "Minting is not currently enabled");
        require(
            msg.value == allowListMintPrice * numberOfTokens,
            "msg.value is incorrect"
        );
        require(
            mintCount + numberOfTokens <= maximumMintAmount,
            "Maximum Mint Amount Reached"
        );

        for (uint256 i = 0; i < numberOfTokens; i++) {
            uint256 tokenId = _tokenIdCounter;
            _safeMint(to, tokenId);
            mintCount += 1;
            emit CdMinted(tokenId, to);
            _tokenIdCounter++;
        }
        mostRecentMinter = to;

        userMintCount[to] += numberOfTokens;

        if (userMintCount[mostCdsMinted] < userMintCount[to]) {
            mostCdsMinted = to;
        }
    }

    function writeToDisc(uint256 tokenId, uint256 songChoiceId) public {
        require(
            ownerOf(tokenId) == msg.sender,
            "Only the owner of this token can set CdMemory"
        );

        require(
            songChoiceId >= 1 && songChoiceId <= 5,
            "Invalid song choice ID"
        );

        CdMemory storage cd = readCdMemory[tokenId];
        require(
            !cd.written,
            "CdMemory is already written and cannot be updated."
        );

        cd.writerAddress = msg.sender;
        cd.songChoiceId = songChoiceId;
        cd.written = true; // Mark the data as written after the initial update.

        //update the write count
        writeCount += 1;

        emit CdMemorySet(tokenId, msg.sender, songChoiceId);
    }

    function multiWriteToDisc(
        uint256[] memory tokenIds,
        uint256[] memory songSelections
    ) public {
        require(
            tokenIds.length == songSelections.length,
            "Input arrays must have the same length"
        );

        for (uint256 i = 0; i < tokenIds.length; i++) {
            uint256 tokenId = tokenIds[i];
            uint256 songChoiceId = songSelections[i];

            // Check if CdMemory is not written before allowing an update
            CdMemory storage cd = readCdMemory[tokenId];
            require(
                ownerOf(tokenId) == msg.sender,
                "Only the owner can set CdMemory"
            );
            require(
                songChoiceId >= 1 && songChoiceId <= 5,
                "Invalid song choice ID"
            );
            require(!cd.written, "One or more tokens are already written.");

            // Update CdMemory and mark it as written
            cd.writerAddress = msg.sender;
            cd.songChoiceId = songChoiceId;
            cd.written = true;

            writeCount += 1;

            emit CdMemorySet(tokenId, msg.sender, songChoiceId);
        }
    }

    //Cross chain writing to disc via the Box

    function multiWriteToDiscSignature(
        uint256[] memory tokenIds,
        uint256[] memory songSelections,
        bytes memory signature
    ) public {
        require(
            tokenIds.length == songSelections.length,
            "tokenIds and songSelections arrays must have the same length"
        );

        //Constructing the signed hash for signer address recovery
        bytes32 messageHash = keccak256(
            abi.encodePacked(tokenIds, songSelections)
        );

        bytes32 ethSignedHash = keccak256(
            abi.encodePacked("\x19Ethereum Signed Message:\n32", messageHash)
        );

        address signer = recoverSigner(ethSignedHash, signature);

        for (uint256 i = 0; i < tokenIds.length; i++) {
            uint256 tokenId = tokenIds[i];
            uint256 songChoiceId = songSelections[i];

            // Check if CdMemory is not written before allowing an update
            CdMemory storage cd = readCdMemory[tokenId];
            require(
                ownerOf(tokenId) == signer,
                "Only the owner can set CdMemory"
            );
            require(
                songChoiceId >= 1 && songChoiceId <= 5,
                "Invalid song choice ID"
            );
            require(!cd.written, "One or more tokens are already written.");

            // Update CdMemory and mark it as written
            cd.writerAddress = signer;
            cd.songChoiceId = songChoiceId;
            cd.written = true;

            writeCount += 1;

            emit CdMemorySet(tokenId, signer, songChoiceId);
        }
    }

    //Helper function to determine signer address based on the signed hash and the signature

    function recoverSigner(
        bytes32 ethSignedHash,
        bytes memory signature
    ) public pure returns (address) {
        // Extract the r, s, and v values from the signature
        (bytes32 r, bytes32 s, uint8 v) = splitSignature(signature);

        // Recover and return the signer address
        return ecrecover(ethSignedHash, v, r, s);
    }

    //Helper Function to split signature into RSV values
    function splitSignature(
        bytes memory signature
    ) public pure returns (bytes32 r, bytes32 s, uint8 v) {
        require(signature.length == 65, "Invalid signature length");

        assembly {
            // Slice the r, s, and v components from the signature
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }
    }

    ////Admin Functions
    function toggleSaleEnabled() public onlyOwner {
        saleEnabled = !saleEnabled;
    }

    // Function to set the minting price, accessible only by the owner.
    function setMintPrice(uint256 price) public onlyOwner {
        mintPrice = price;
    }

    function setBeneficiaryAddress(
        address _beneficiaryAddress
    ) public onlyOwner {
        require(_beneficiaryAddress != address(0), "Invalid address");
        beneficiaryAddress = _beneficiaryAddress;
    }

    // Function to withdraw the contract's balance (received ETH) to the owner.
    function withdrawBalance() public onlyOwner {
        require(
            beneficiaryAddress != address(0),
            "Beneficiary address is not set"
        );
        (bool success, ) = payable(beneficiaryAddress).call{
            value: address(this).balance
        }("");
        require(success, "Transfer failed");
    }
}
